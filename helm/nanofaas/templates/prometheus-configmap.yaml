{{- if .Values.prometheus.create -}}
{{- $legacyKubeletResourceMetricsEnabled := .Values.prometheus.kubeletResourceMetrics.enabled -}}
{{- $containerMetricsEnabled := or .Values.prometheus.containerMetrics.enabled $legacyKubeletResourceMetricsEnabled -}}
{{- $containerMetricsMode := default "kubelet" .Values.prometheus.containerMetrics.mode -}}
{{- $containerMetricsKubeletEnabled := or $legacyKubeletResourceMetricsEnabled (and .Values.prometheus.containerMetrics.enabled (eq $containerMetricsMode "kubelet")) -}}
{{- $containerMetricsDaemonsetEnabled := and .Values.prometheus.containerMetrics.enabled (eq $containerMetricsMode "daemonset") -}}
apiVersion: v1
kind: ConfigMap
metadata:
  name: nanofaas-prometheus-config
  namespace: {{ include "nanofaas.namespace" . | quote }}
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
      evaluation_interval: 15s

    rule_files:
      - /etc/prometheus/rules.yml

    scrape_configs:
      - job_name: prometheus
        scrape_interval: 10s
        static_configs:
          - targets: ['localhost:9090']

      # Scrape Services/Endpoints annotated with prometheus.io/scrape=true in the Nanofaas namespace.
      - job_name: nanofaas-endpoints
        scrape_interval: 5s
        honor_labels: false
        kubernetes_sd_configs:
          - role: endpoints
            namespaces:
              names:
                - {{ include "nanofaas.namespace" . }}
        relabel_configs:
          - action: keep
            source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape]
            regex: true
          - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port]
            action: replace
            separator: ;
            regex: ([^:]+)(?::\\d+)?;(\\d+)
            replacement: $1:$2
            target_label: __address__
          - action: replace
            regex: (.+)
            source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path]
            target_label: __metrics_path__
          - action: labelmap
            regex: __meta_kubernetes_service_label_(.+)
          - source_labels: [__meta_kubernetes_namespace]
            action: replace
            target_label: kubernetes_namespace
          - source_labels: [__meta_kubernetes_service_name]
            action: replace
            target_label: kubernetes_service_name
        metric_relabel_configs:
          # OpenFaaS-style label alias
          - source_labels: [function]
            regex: (.+)
            target_label: function_name
            replacement: $1
            action: replace

      # Scrape Pods annotated with prometheus.io/scrape=true in the Nanofaas namespace.
      - job_name: nanofaas-pods
        scrape_interval: 5s
        honor_labels: false
        kubernetes_sd_configs:
          - role: pod
            namespaces:
              names:
                - {{ include "nanofaas.namespace" . }}
        relabel_configs:
          - action: keep
            source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
            regex: true
          - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
            action: replace
            regex: ([^:]+)(?::\\d+)?;(\\d+)
            replacement: $1:$2
            target_label: __address__
          - action: replace
            regex: (.+)
            source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
            target_label: __metrics_path__
          - action: labelmap
            regex: __meta_kubernetes_pod_label_(.+)
          - source_labels: [__meta_kubernetes_namespace]
            action: replace
            target_label: kubernetes_namespace
          - source_labels: [__meta_kubernetes_pod_name]
            action: replace
            target_label: kubernetes_pod_name
        metric_relabel_configs:
          # OpenFaaS-style label alias
          - source_labels: [function]
            regex: (.+)
            target_label: function_name
            replacement: $1
            action: replace

      {{- if $containerMetricsKubeletEnabled }}
      # Optional: scrape cAdvisor metrics via kubelet/apiserver proxy.
      - job_name: kubernetes-cadvisor
        scrape_interval: 10s
        honor_timestamps: false
        scheme: https
        tls_config:
          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
          insecure_skip_verify: {{ if $legacyKubeletResourceMetricsEnabled }}{{ .Values.prometheus.kubeletResourceMetrics.insecureSkipVerify }}{{ else }}{{ .Values.prometheus.containerMetrics.kubelet.insecureSkipVerify }}{{ end }}
        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
        kubernetes_sd_configs:
          - role: node
        relabel_configs:
          - action: labelmap
            regex: __meta_kubernetes_node_label_(.+)
          - target_label: __address__
            replacement: kubernetes.default.svc:443
          - source_labels: [__meta_kubernetes_node_name]
            regex: (.+)
            target_label: __metrics_path__
            replacement: /api/v1/nodes/${1}/proxy/metrics/cadvisor
        metric_relabel_configs:
          # Keep only container CPU/memory signals used by runtime A/B reporting.
          - source_labels: [__name__]
            regex: container_cpu_usage_seconds_total|container_memory_working_set_bytes|container_memory_usage_bytes
            action: keep
          - source_labels: [namespace]
            regex: (.+)
            target_label: kubernetes_namespace
            replacement: $1
            action: replace
          - source_labels: [pod]
            regex: (.+)
            target_label: kubernetes_pod_name
            replacement: $1
            action: replace
          - source_labels: [pod]
            regex: '^fn-(.+)-[0-9a-f]+-[a-z0-9]+$'
            target_label: function_name
            replacement: '$1'
            action: replace
      {{- end }}

      {{- if and $containerMetricsEnabled $containerMetricsDaemonsetEnabled }}
      # Optional: scrape cAdvisor metrics from nanofaas-cadvisor DaemonSet.
      - job_name: nanofaas-cadvisor
        scrape_interval: 10s
        honor_timestamps: false
        kubernetes_sd_configs:
          - role: endpoints
            namespaces:
              names:
                - {{ include "nanofaas.namespace" . }}
        relabel_configs:
          - source_labels: [__meta_kubernetes_service_name]
            regex: nanofaas-cadvisor
            action: keep
          - source_labels: [__meta_kubernetes_endpoint_port_name]
            regex: http
            action: keep
          - source_labels: [__meta_kubernetes_namespace]
            regex: (.+)
            target_label: kubernetes_namespace
            replacement: $1
            action: replace
        metric_relabel_configs:
          - source_labels: [__name__]
            regex: container_cpu_usage_seconds_total|container_memory_working_set_bytes|container_memory_usage_bytes
            action: keep
          - source_labels: [namespace]
            regex: (.+)
            target_label: kubernetes_namespace
            replacement: $1
            action: replace
          - source_labels: [pod]
            regex: (.+)
            target_label: kubernetes_pod_name
            replacement: $1
            action: replace
          - source_labels: [pod]
            regex: '^fn-(.+)-[0-9a-f]+-[a-z0-9]+$'
            target_label: function_name
            replacement: '$1'
            action: replace
          - source_labels: [container_label_io_kubernetes_pod_name]
            regex: '^fn-(.+)-[0-9a-f]+-[a-z0-9]+$'
            target_label: function_name
            replacement: '$1'
            action: replace
      {{- end }}
  rules.yml: |
    groups:
      # Best-effort OpenFaaS metric name compatibility using Nanofaas control-plane counters/gauges.
      #
      # Notes:
      # - Nanofaas does not have an OpenFaaS "gateway", so these are derived from control-plane metrics.
      # - "code" is approximated (success=200, error=500, timeout=504, queue_rejected=429).
      - name: openfaas_compat
        interval: 15s
        rules:
          - record: gateway_function_invocation_total
            expr: label_replace(function_success_total, "code", "200", "function", ".*")
          - record: gateway_function_invocation_total
            expr: label_replace(function_error_total, "code", "500", "function", ".*")
          - record: gateway_function_invocation_total
            expr: label_replace(function_timeout_total, "code", "504", "function", ".*")
          - record: gateway_function_invocation_total
            expr: label_replace(function_queue_rejected_total, "code", "429", "function", ".*")

          # Approximate "started" as "dispatch" (execution handed off to a function pod).
          - record: gateway_function_invocation_started
            expr: function_dispatch_total

          # Approximate "inflight" using the control-plane queue in-flight gauge.
          - record: gateway_function_invocation_inflight
            expr: function_in_flight OR function_inFlight

          # Approximate OpenFaaS queue-worker pending messages using Nanofaas per-function queue depth.
          - record: queue_worker_pending_messages
            expr: function_queue_depth

          # Approximate OpenFaaS function duration metrics using Micrometer Timer output.
          - record: gateway_function_invocation_duration_seconds_count
            expr: function_latency_ms_seconds_count
          - record: gateway_function_invocation_duration_seconds_sum
            expr: function_latency_ms_seconds_sum

      # Best-effort OpenFaaS Pro recording rules for "current load" (subset: rps/queue/capacity).
      - name: openfaas_pro_load
        interval: 15s
        rules:
          - record: job:function_current_load:sum
            expr: ceil(sum by (function_name) ( rate( gateway_function_invocation_total{}[30s] ) ) and on (function_name) avg by (function_name) (gateway_service_target_load{scaling_type="rps"}) > 1)
            labels:
              scaling_type: rps
          - record: job:function_current_load:sum
            expr: avg(queue_worker_pending_messages{}) by (function_name) and on (function_name) avg by (function_name) (gateway_service_target_load{scaling_type="queue"}) > bool 1
            labels:
              scaling_type: queue
          - record: job:function_current_load:sum
            expr: ceil(sum by (function_name) ( max_over_time( gateway_function_invocation_inflight[45s:5s])) and on (function_name) avg by(function_name) (gateway_service_target_load{scaling_type="capacity"}) > bool 1)
            labels:
              scaling_type: capacity

          - record: job:function_current_started:max_sum
            expr: max_over_time(sum by (function_name) (rate( gateway_function_invocation_started{}[1m]))[1m:5s]) > 0

      {{- if $containerMetricsEnabled }}
      # Optional: OpenFaaS Pro-like CPU load rule (requires cAdvisor CPU metric).
      - name: openfaas_pro_cpu
        interval: 15s
        rules:
          - record: job:function_current_load:sum
            expr: ceil(sum(irate(container_cpu_usage_seconds_total{function_name!=""}[1m]) * 1000) by (function_name) * on (function_name) avg by (function_name) (gateway_service_target_load{scaling_type="cpu"} > bool 1))
            labels:
              scaling_type: cpu
      {{- end }}

      # OpenFaaS CE ships a basic alert example; keep it for parity.
      - name: openfaas_alerts
        rules:
          - alert: APIHighInvocationRate
            expr: sum(rate(gateway_function_invocation_total{code="200"}[10s])) BY (function_name) > 5
            for: 5s
            labels:
              service: nanofaas
              severity: major
            annotations:
              description: High invocation total on "{{ "{{" }}$labels.function_name{{ "}}" }}"
              summary: High invocation total on "{{ "{{" }}$labels.function_name{{ "}}" }}"
{{- end -}}
